# Priority_Queue(우선순위 큐)

- 개념
    - Heap 자료구조를 응용한 대표적인 사례가 Priority_Queue(우선순위 큐)이다.
    - Prioriy Queue는 queue의 한 종류로 이름 그대로 우선순위에 따라 정렬된 Queue이다.
    - 어떤 원소가 push되면 주어진 우선순위에 맞춰서 Queue가 정렬되고, pop은 정렬된 Queue의 앞에서 이루어진다. 자료구조 Heap으로 구현되었기 때문에, 특정 운소를 push해 생기는 정렬 과정은 시간복잡도 O(log N)만에 이루어진다.
    - **우선순위 큐는 배열, 연결리스트 등의 여러 가지 방법으로 구현이 가능하지만 가장 효율적인 구조는 heap이다.**
    - **우선순위 큐는 삭제 연산에서 어떤 요소가 먼저 삭제되는가에 따라 최소 우선순위 큐와 최대 우선위 큐로 나누어진다**
        - 최대 우선순위 큐는 우선순위가 가장 높은 요소가 먼저 삭제된다.
        - 최소 우선순위 큐는 우선순위가 가장 낮은 요소가 먼저 삭제된다.
- 구현 방법
    - 배열을 사용하는 방법
        - 정렬 되지 않은 배열을 이용하는 방법
            
            → 정렬 되지 않은 배열을 사용하게 되면 삽입은 가장 간단, 그냥 기존의 요소들의 맨 끝에 붙이면 되기 때문에 **시간 복잡도는 O(1)이다**.  그러나 삭제시 우선순위를 기반으로 모든 요소들에 대해 탐색을 진행해야 하기 때문에 **시간 복잡도는 O(N)이다.** 이 말은 즉, 배열이 정렬 되지 않았기 때문에 발생하는 상황이라는 말이다.
            
            → 단점 : 임의의 위치에 대해 요소가 삭제된 이후 뒤에 있는 요소들을 앞으로 한 칸씩 이동시켜야 하는 부담이 있다.
            
        - 정렬된 배열을 이용하는 방법
            
            → 삽입할 위치를 찾기 위해 탐색을 진행해야 한다. 여기서는 방법이 여러가지가 있지만 대표적으로 순차탐색과 상대적으로 빠르게 찾기 위해서는 이진 탐색을 사용할 수 있다. 탐색을 통해 삽입 위치를 찾은 다음 삽입 위치에 대해 공간을 만들기 위해 배열을 한 칸씩 뒤로 밀어야 되기 때문에 삽입시 **시간 복잡도는 O(N)이다.**  삭제 연산의 경우 정렬 되어 있기 때문에 우선순위를 기반으로 가장 앞 or 가장 뒤에 있는 요소를 삭제하기 때문에 **시간 복잡도는 O(1)이다.**
            
        
    - 연결 리스트를 사용하는 방법
        - 정렬 되지 않은 연결 리스트를 이용하는 방법
            
            → 삽입 시에는 첫 번째 노드로 삽입하는 것이 유리하다. 물론 배열과 달리 다른 노드들의 이동은 필요 없다. 따라서 **시간 복잡도는 O(1)이다**. 삭제 시에는 포인터를 따라서 모든 노드를 방문하고 우선순위에 대해 노드를 찾아야 한다. 이 경우 **시간 복잡도는 O(N)이다.**
            
        - 정렬 된 연결 리스트를 이용하는 방법
            
            → 삽입 시에 첫 번째 노드로 삽입하는 것이 유리하다. why? 마지막 노드까지의 접근은 시간 복잡도 O(N)이다. 헤드 포인터부터 NULL이 나올 때까지 탐색을 진행해야 되기 때문이다. 따라서 첫 번째 노드로 삽입 연산을 진행하는 경우 **시간 복잡도는 O(1)이다.**
            
            → 삭제 시에는 포인터를 따라서 모든 노드를 방문하고 우선순위에 대해 노드를 탐색하고 삭제 연산을 진행하면 되기 때문에 **시간 복잡도는 O(N)이다.** **우선순위의 기준이 높고, 낮고일 경우 시간 복잡도가 바뀌는 게 아니라 정렬의 기준이 바뀌는 것이므로 시간 복잡도는 O(N)으로 동일하니 헷갈리지 말자.**
            
            → 결과적으로는 배열로 구현한 방법과는 시간 복잡도가 차이가 없다.
            
        - Heap을 사용하는 방법
            
            → 힙은 완전 이진트리의 일종으로 우선순위 큐를 위해 만들어진 자료구조이다. 힙은 일종의 반 정렬 상태를 유지한다. 즉, 요소들이 완전히 정렬된 것은 아니지만 전혀 정렬되지 않은 것도 아닌 상태를 이용해 우선순위 큐를 구현한다. 힙의 시간 복잡도는 삽입과 삭제 모두 **O(log2n)으로 다른 방법보다 상당히 유리하다.**
            
            →**주의 사항 : O(N)과 o(log2n)은 큰 차이가 있다는 것을 인지해야 한다. 왜냐면 시간 복잡도는 최선, 평균이 아닌 “최악”을 고려해야 하기 때문이다. 고작 1, 2, 4, 8 같이 작은 수가 아닌 1024, 2048.. 등 큰 수를 넣어야 의미가 있기 때문이다.**
            
- Heap의 개념
    
    → 힙은 간단히 말하면 부모 노드의 키 값이 자식 노드이 키 값보다 큰 이진트리를 말한다.
    
    ex) **A가 B의 부모 노드인 경우 key(A) ≥ key(B)의 조건은 항상 성립하는 이진트리를 말한다.**
    
    ![Untitled](Priority_Queue(%E1%84%8B%E1%85%AE%E1%84%89%E1%85%A5%E1%86%AB%E1%84%89%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B1%20%E1%84%8F%E1%85%B2)%20c067aaee5ff543b2afbec8424614c347/Untitled.png)
    
    그림 10.5는 각각 최대 힙, 최소 힙 트리를 보여주고 있다. a의 경우 항상 key(부모노드) ≥ key(서브 노드)의 조건이 성립하고, b의 경우 항상 key(부모노드) ≤ key(서브 노드)의 조건이 성립한다.
    
    → 주의 사항 : 힙 트리에서는 중복된 값을 허용함을 인지해야 한다. 이진 탐색 트리에서는 중복된 값을 허용하지 않았다.
    
    → 또한 위의 두 종류의 힙 트리를 보면 공통점이 있다. 두 종류의 트리 모두 완전 이진 트리의 꼴이라는 것. **힙 트리는 항상 완전 이진 트리의 꼴을 유지하고 있어야 힙 트리라고 할 수 있다.**
    
    ![Untitled](Priority_Queue(%E1%84%8B%E1%85%AE%E1%84%89%E1%85%A5%E1%86%AB%E1%84%89%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B1%20%E1%84%8F%E1%85%B2)%20c067aaee5ff543b2afbec8424614c347/Untitled%201.png)
    

- 힙의 구현 방법
    
    힙은 완전 이진트리의 꼴의 모습을 보이고 있으므로 중간에 비어 있는 요소가 없다. **힙을 저장하는 효과적인 자료구조는 배열이다.** +) 프로그램 구현을 상대적으로 쉽게 하기 위해 첫 번째 인덱스는 0이 아닌 1로 잡자.(그냥 이게 편해서 쓰는 거라고 함)
    
    ![Untitled](Priority_Queue(%E1%84%8B%E1%85%AE%E1%84%89%E1%85%A5%E1%86%AB%E1%84%89%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B1%20%E1%84%8F%E1%85%B2)%20c067aaee5ff543b2afbec8424614c347/Untitled%202.png)
    
    다음의 그림을 참고하면 인덱스를 쉽게 구할 수 있다. **그림 보다 더 많은 노드를 가지게 된다면 해당 자식 노드에 대해 level탐색을 진행할텐데 이럴 경우 시간 복잡도가 O(N)**으로 발생할 수 있기에 간단한 식을 써 자식 노드의 인덱스를 손 쉽게 구할 수 있다.
    
    - **왼쪽 자식의 인덱스 = (부모 인덱스) * 2**
    - **오른쪽 자식의 인덱스 = (부모 인덱스) * 2 + 1**
    - **부모 노드의 인덱스 = (자식의 인덱스) / 2**
    
- 기본 사용방법
    - #include <queue>로 흔히 사용하는 queue와 동일하다.
    - priority_queue<자료형, Container, 비교함수> 변수명
    → 선언한 자료형 변수들을 비교함수에 따라 정렬하는 Priority_queue(우선순위 큐)를 선언,
    - priority_queue<자료형> 변수명
    → 선언한 자료형 변수들을 내림차순에 따라 정렬하는 priority_queue(큐를 선언)
    →ex) priority_queue<int, vector<int>, greater<int>> pq; (오름차순)으로 정렬하기 위해 greater을 선언, default는 내림차순이다.
    - 나머지 기본 함수는 queue와 동일하다.
- 예시 코드
    
    ```cpp
    //내림차순
    
    #include <queue>
    #include <iostream>
    using namespace std;
    
    int main() {
      // 우선순위 큐를 <자료형, 구현체, 비교연산자> 를 이용하여 선언한다.
    	// 별도의 비교연사자를 사용하지 않고 default로 int가 큰 값이 우선한다.
      priority_queue <int, vector<int>> pq;
      
      pq.push(5);
      pq.push(3);
      pq.push(6);
      pq.push(7);
    
      while(!pq.empty()) {
        int temp = pq.top();
        cout << temp;
        pq.pop();
      }
      // 출력결과
      // 7653
      return 0;
    }
    ```
    
    ```cpp
    //오름차순
    #include <queue>
    #include <iostream>
    using namespace std;
    
    int main() {
      // 우선순위 큐를 <자료형, 구현체, 비교연산자> 를 이용하여 선언한다.
      // 비교연산자에 greater<int>를 사용하여 int가 작은값이 우선한다.
      priority_queue <int, vector<int>, greater<int> > pq;
      
      pq.push(5);
      pq.push(3);
      pq.push(6);
      pq.push(7);
    
      while(!pq.empty()) {
        int temp = pq.top();
        cout << temp;
        pq.pop();
      }
      // 출력결과
      // 3567
      return 0;
    }
    ```
    
    ```cpp
    #include <queue>
    #include <iostream>
    using namespace std;
    
    // 비교연산 선언
    // int형인 a와 b가 있을때
    // 반환에 a > b 를 입력하면 작은수부터 출력한다.
    // (반대로 a < b 를 입력하면 큰수부터 출력한다.) 
    struct cmp {
      bool operator()(int a, int b) {
        return a > b;
      }
    };
    
    int main() {
      priority_queue <int, vector<int>, cmp> pq;
      
      pq.push(5);
      pq.push(3);
      pq.push(6);
      pq.push(7);
    
      while(!pq.empty()) {
        int temp = pq.top();
        cout << temp;
        pq.pop();
      }
      // 출력결과
      // 3567
      return 0;
    }
    ```