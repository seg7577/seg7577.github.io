<!doctype html><!-- This site was created with Hugo Blox. https://hugoblox.com --><!-- Last Published: 2024년 10월 4일 --><html lang=ko dir=ltr data-wc-theme-default=system><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Hugo Blox Builder 0.2.0"><meta name=author content="m._.se0k"><meta name=description content="전북대 권민석"><link rel=alternate hreflang=en href=http://localhost:1313/en/study/problemsolving/><link rel=alternate hreflang=ko href=http://localhost:1313/ko/study/problemsolving/><link rel=stylesheet href=/css/themes/green.min.css><link href=/dist/wc.min.css rel=stylesheet><script>window.hbb={defaultTheme:document.documentElement.dataset.wcThemeDefault,setDarkTheme:()=>{document.documentElement.classList.add("dark"),document.documentElement.style.colorScheme="dark"},setLightTheme:()=>{document.documentElement.classList.remove("dark"),document.documentElement.style.colorScheme="light"}},console.debug(`Default Hugo Blox Builder theme is ${window.hbb.defaultTheme}`),"wc-color-theme"in localStorage?localStorage.getItem("wc-color-theme")==="dark"?window.hbb.setDarkTheme():window.hbb.setLightTheme():(window.hbb.defaultTheme==="dark"?window.hbb.setDarkTheme():window.hbb.setLightTheme(),window.hbb.defaultTheme==="system"&&(window.matchMedia("(prefers-color-scheme: dark)").matches?window.hbb.setDarkTheme():window.hbb.setLightTheme()))</script><script>document.addEventListener("DOMContentLoaded",function(){let e=document.querySelectorAll("li input[type='checkbox'][disabled]");e.forEach(e=>{e.parentElement.parentElement.classList.add("task-list")});const t=document.querySelectorAll(".task-list li");t.forEach(e=>{let t=Array.from(e.childNodes).filter(e=>e.nodeType===3&&e.textContent.trim().length>1);if(t.length>0){const n=document.createElement("label");t[0].after(n),n.appendChild(e.querySelector("input[type='checkbox']")),n.appendChild(t[0])}})})</script><link rel=alternate href=/ko/study/problemsolving/index.xml type=application/rss+xml title="m._.se0k's BLOG"><link rel=icon type=image/png href=/media/icon_hu3247630877640252165.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu4166356570829923896.png><link rel=canonical href=http://localhost:1313/ko/study/problemsolving/><meta property="twitter:card" content="summary"><meta property="twitter:site" content="@GetResearchDev"><meta property="twitter:creator" content="@GetResearchDev"><meta property="og:site_name" content="m._.se0k's BLOG"><meta property="og:url" content="http://localhost:1313/ko/study/problemsolving/"><meta property="og:title" content="m._.se0k's BLOG"><meta property="og:description" content="전북대 권민석"><meta property="og:image" content="http://localhost:1313/media/icon_hu7729264130191091259.png"><meta property="twitter:image" content="http://localhost:1313/media/icon_hu7729264130191091259.png"><meta property="og:locale" content="ko"><title>m._.se0k's BLOG</title><style>@font-face{font-family:inter var;font-style:normal;font-weight:100 900;font-display:swap;src:url(/dist/font/Inter.var.woff2)format(woff2)}</style><link type=text/css rel=stylesheet href=/dist/pagefind/pagefind-ui.be766eb419317a14ec769d216e9779bfe8f3737c80e780f4ba0dafb57a41a482.css integrity="sha256-vnZutBkxehTsdp0hbpd5v+jzc3yA54D0ug2vtXpBpII="><script src=/dist/pagefind/pagefind-ui.87693d7c6f2b3b347ce359d0ede762c033419f0a32b22ce508c335a81d841f1b.js integrity="sha256-h2k9fG8rOzR841nQ7ediwDNBnwoysizlCMM1qB2EHxs="></script><script>window.hbb.pagefind={baseUrl:"/"}</script><style>html.dark{--pagefind-ui-primary:#eeeeee;--pagefind-ui-text:#eeeeee;--pagefind-ui-background:#152028;--pagefind-ui-border:#152028;--pagefind-ui-tag:#152028}</style><script>window.addEventListener("DOMContentLoaded",e=>{new PagefindUI({element:"#search",showSubResults:!0,baseUrl:window.hbb.pagefind.baseUrl,bundlePath:window.hbb.pagefind.baseUrl+"pagefind/"})}),document.addEventListener("DOMContentLoaded",()=>{let e=document.getElementById("search"),t=document.getElementById("search_toggle");t&&t.addEventListener("click",()=>{if(e.classList.toggle("hidden"),e.querySelector("input").value="",e.querySelector("input").focus(),!e.classList.contains("hidden")){let t=document.querySelector(".pagefind-ui__search-clear");t&&!t.hasAttribute("listenerOnClick")&&(t.setAttribute("listenerOnClick","true"),t.addEventListener("click",()=>{e.classList.toggle("hidden")}))}})})</script><script defer src=/js/hugo-blox-ko.min.js integrity></script></head><body class="dark:bg-hb-dark dark:text-white page-wrapper" id=top><div id=page-bg></div><div class="page-header sticky top-0 z-30"><header id=site-header class=header><nav class="navbar px-3 flex justify-left"><div class="order-0 h-100"><a class=navbar-brand href=/ko/ title="m._.se0k's BLOG">m._.se0k BLOG</a></div><input id=nav-toggle type=checkbox class=hidden>
<label for=nav-toggle class="order-3 cursor-pointer flex items-center lg:hidden text-dark dark:text-white lg:order-1"><svg id="show-button" class="h-6 fill-current block" viewBox="0 0 20 20"><title>Open Menu</title><path d="M0 3h20v2H0V3zm0 6h20v2H0V9zm0 6h20v2H0V0z"/></svg><svg id="hide-button" class="h-6 fill-current hidden" viewBox="0 0 20 20"><title>Close Menu</title><polygon points="11 9 22 9 22 11 11 11 11 22 9 22 9 11 -2 11 -2 9 9 9 9 -2 11 -2" transform="rotate(45 10 10)"/></svg></label><ul id=nav-menu class="navbar-nav order-3 hidden lg:flex w-full pb-6 lg:order-1 lg:w-auto lg:space-x-2 lg:pb-0 xl:space-x-8 justify-left"><li class="nav-item nav-dropdown group relative"><span class="nav-link
inline-flex items-center">소개<svg class="h-4 w-4 fill-current inline-block" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></span><ul class="nav-dropdown-list lg:group-hover:visible lg:group-hover:opacity-100"><li class=nav-dropdown-item><a class=nav-dropdown-link href=/ko/introduction/about-me>나에 대한 소개</a></li><li class=nav-dropdown-item><a class=nav-dropdown-link href=/ko/introduction/skills>기술</a></li></ul></li><li class="nav-item nav-dropdown group relative"><span class="nav-link
inline-flex items-center">블로그<svg class="h-4 w-4 fill-current inline-block" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></span><ul class="nav-dropdown-list lg:group-hover:visible lg:group-hover:opacity-100"><li class=nav-dropdown-item><a class=nav-dropdown-link href=/ko/blog/challenges>챌린지 및 대회</a></li><li class=nav-dropdown-item><a class=nav-dropdown-link href=/ko/blog/challenges>기록</a></li></ul></li><li class=nav-item><a class=nav-link href=/ko/>홈</a></li><li class="nav-item nav-dropdown group relative"><span class="nav-link
inline-flex items-center">넷플릭스<svg class="h-4 w-4 fill-current inline-block" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></span><ul class="nav-dropdown-list lg:group-hover:visible lg:group-hover:opacity-100"><li class=nav-dropdown-item><a class=nav-dropdown-link href=/ko/mynetflix/korean-dramas/>한국</a></li><li class=nav-dropdown-item><a class=nav-dropdown-link href=/ko/mynetflix/western-shows/>서부</a></li></ul></li><li class="nav-item nav-dropdown group relative"><span class="nav-link
inline-flex items-center">공부<svg class="h-4 w-4 fill-current inline-block" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></span><ul class="nav-dropdown-list lg:group-hover:visible lg:group-hover:opacity-100"><li class=nav-dropdown-item><a class=nav-dropdown-link href=/ko/study/project>프로젝트</a></li><li class=nav-dropdown-item><a class=nav-dropdown-link href=/ko/study/problemsolving>알고리즘 및 문제해결</a></li></ul></li></ul><div class="order-1 ml-auto flex items-center md:order-2 lg:ml-0"><button aria-label=search class="text-black hover:text-primary inline-block px-3 text-xl dark:text-white" id=search_toggle><svg height="16" width="16" viewBox="0 0 512 512" fill="currentcolor"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg></button><div class="px-3 text-black hover:text-primary-700 dark:text-white dark:hover:text-primary-300
[&.active]:font-bold [&.active]:text-black/90 dark:[&.active]:text-white"><button class="theme-toggle mt-1" accesskey=t title=appearance><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="dark:hidden"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="dark:block [&:not(dark)]:hidden"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div><div class="pl-1 mr-5 text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200
[&.active]:font-bold [&.active]:text-black/90 dark:[&.active]:text-white"><div class="flex justify-items-start"><button title=Languages data-state=closed data-hb-language-chooser class="grow h-7 rounded-md px-2 text-left text-xs font-medium text-gray-600 transition-colors dark:text-gray-400 hover:bg-gray-100 hover:text-gray-900 dark:hover:bg-primary-100/5 dark:hover:text-gray-50" type=button aria-label=Languages><div class="flex items-center gap-2 capitalize"><svg height="18" viewBox="0 0 24 24"><path fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 21a9.004 9.004.0 008.716-6.747M12 21a9.004 9.004.0 01-8.716-6.747M12 21c2.485.0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485.0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997.0 017.843 4.582M12 3A8.997 8.997.0 004.157 7.582m15.686.0A11.953 11.953.0 0112 10.5c-2.998.0-5.74-1.1-7.843-2.918m15.686.0A8.959 8.959.0 0121 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919.0 0112 16.5a17.92 17.92.0 01-8.716-2.247m0 0A9.015 9.015.0 013 12c0-1.605.42-3.113 1.157-4.418"/></svg><span>한국어</span></div></button><ul class="fixed m-0 min-w-[100px] hidden z-20 max-h-64 overflow-auto rounded-md ring-1 ring-black/5 bg-white py-1 text-sm shadow-lg dark:ring-white/20 dark:bg-neutral-800" style="inset:auto auto 0 0"><li class="flex flex-col"><a href=http://localhost:1313/en/study/problemsolving/ class="relative cursor-pointer text-gray-800 dark:text-gray-100 hover:bg-primary-50 hover:text-primary-600 hover:dark:bg-primary-500/10 hover:dark:text-primary-200 whitespace-nowrap py-1.5 transition-colors ltr:pl-3 ltr:pr-9 rtl:pr-3 rtl:pl-9">English</a></li></ul></div></div></div></nav></header><div id=search class="hidden p-3"></div></div><div class="page-body my-10"><div class="max-w-prose mx-auto flex justify-center"><article class="prose prose-slate lg:prose-xl dark:prose-invert"><h1 class=lg:text-6xl></h1><h1 id=자료구조>자료구조</h1><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/Graph%201dbefd8ae8a34c51b30b61aff6659599.md>Graph</a></p><p><a href=/problemSolving/dataStructure/bfs>BFS</a></p><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/DFS%202e2793922c3f4419a5b9deb5e968f9c0.md>DFS</a></p><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%20%28Recursion%29%20237e0d4ae1dc45e8a57b71df35daa14f.md>재귀 (Recursion)</a></p><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/Tree%20448e909ae2e945c69376117b1848d153.md>Tree</a></p><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20d3337e3da09c419cbc3ad1f4ee9bc8e6.md>이진탐색</a></p><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/Map%2022aee892d718457098f66dff9020f806.md>Map</a></p><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/Heap%2082a6f64cd5a94c17843d917590032861.md>Heap</a></p><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/Priority_Queue%28%E1%84%8B%E1%85%AE%E1%84%89%E1%85%A5%E1%86%AB%E1%84%89%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B1%20%E1%84%8F%E1%85%B2%29%20c067aaee5ff543b2afbec8424614c347.md>Priority_Queue(우선순위 큐)</a></p><p><a href=%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20eddaca353e5b4f03a0f1824e4cd00a71/Unordered_map%203fd4f4cbc33a44a3bcc0bbcd0a5b3fd1.md>Unordered_map</a></p></article></div><div class="flex flex-col items-center"><div class="container max-w-[65ch] mx-auto bg-white dark:bg-zinc-900 rounded-xl border-gray-100 dark:border-gray-700 border shadow-md overflow-hidden my-5"><a href=/ko/study/problemsolving/datastructure/bfs/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold">BFS!</div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">BFS //BFS 개념 #include &lt;bits/stdc++.h> #include &lt;iostream> #include &lt;queue> #define X first #define Y second //pair가 first와 second를 기반으로 접근하기 때문에 선언 using namespace std; int board[502][502] = {}; bool vis[502][502]; //방문 여부를 저장하기 위한 bool형 이차원 배열 int n = 7, m = 10; //행과 열의 범위 int dx[4] = { 1, 0, -1, 0 }; int dy[4] = { 0, 1, 0, -1 }; int main() { ios::sync_with_stdio(0); cin.tie(0); queue&lt;pair&lt;int, int>> Q;// vis[0][0] = 1; //시작점은 1로 표시하고 시작, 과정1, 자주하는 실수 1번 : "시작점에 방문했다는 표시를 남기지 않는다." Q.push({ 0, 0 }); //시작점이므로 Q에 넣고 시작, 과정1 while (!Q.empty()) //큐가 비면 1을 반환하고 큐가 차있으면 0을 반환 하지만 !을 붙였으니, 비면 0을 반환 차있으면 1을 반환 //상하좌우 인접한 좌표를 모두 방문했거나, 조건에 충족하지 않을 경우 큐가 비게 되므로 그때 0을 반환할 것이다. { pair&lt;int, int> cur = Q.front(); //큐의 과정 2번을 진행하기 위해 pair 선언한 cur에 큐의 front 값을 넣음 Q.pop(); // 자주하는 실수 2번에서 말한 빼는 경우가 이곳임 //front 했으면 다음 비교를 위해 cur에 저장한 이후 바로 pop하여 삭제 cout &lt;&lt; '(' &lt;&lt; cur.X &lt;&lt; ", " &lt;&lt; cur.Y &lt;&lt; ") -> "; for (int dir = 0; dir &lt; 4; dir++) // dir은 상하좌우로 (x,y) 좌표를 와리가리 치기 위해 반복을 4로 함 { int nx = cur.X + dx[dir]; int ny = cur.Y + dy[dir]; //좌표를 상 or 하 or 좌 or 우로 이동시키고 그값을 각각 nx, ny에 저장하여 이후 조건과 비교할 수 있게 만듦 if (nx &lt; 0 || nx >= n || ny &lt; 0 || ny >= m) continue; //#상하좌우로 이동시킨 좌표값이 혹여나 음수이거나 주어진 n과 m의 값에 벗어나면 바로 continue함 이러기 위해 nx와 ny를 만든 이유1 if (vis[nx][ny] || board[nx][ny] != 1) continue; //#상하좌우로 이동시킨 좌표값이 혹여나 이미 방문했거나 우리가 원하는 조건에 충족하지 못한 칸이면 바로 continue함 nx와 ny를 만든 이유2 vis[nx][ny] = 1; //"자주 하는 실수 2 : "큐에 넣을 때 방문했다는 표시를 하는 대신 큐에서 빼낼 때 방문했다는 표시를 남긴 경우" 조심하기, 실수 2번 같은 경우는 메모리 초과 or 시간 초과로 이어지는 경우임 //위의 2개의 if문의 조건을 불충족하였다면 방문하지 않았고, 우리가 원하는 조건을 충족하고, 좌표의 값이 범위에 벗어나지 않는 것이므로 방문하였단 표시를 남겨주기 위해 vis의 좌표 값에 1을 넣어줌 Q.push({ nx, ny }); //이 for문을 빠져 나간 이후 현재 방문한 좌표의 상하좌우를 탐색하기 위해 큐에 저장 } } } //자주 하는 실수 3 : "이웃한 원소가 범위를 벗어나는지에 대한 체크를 잘못했다.", 44번째의 if문과 47번째의 if문의 실행 순서를 바꾼다면 예를 들어 vis[-1][0] 이러한 좌표 값을 참조할 수 있어 런타임에러가 날 수 있으므로 일단 범위를 먼저 체크하는 것임 //BOJ-2178 미로 탐색 #include &lt;iostream> #include &lt;queue> #include &lt;string> #include &lt;algorithm> #include &lt;bits/stdc++.h> #define X first #define Y second using namespace std; string str_board[105]; int bord[105][105]; int vis[105][105]; int dx[4] = { 1, 0, -1, 0 }; int dy[4] = { 0, 1, 0, -1 }; int n, m; int main() { ios::sync_with_stdio(0); cin.tie(0); cin >> n >> m; for (int i = 0; i &lt; n; i++) //board 입력 cin >> str_board[i]; for (int i = 0; i &lt; n; i++) fill(vis[i], vis[i] + m, -1);//값으로 특점 범위(first, last , val)를 채우는 역할을 하는 함수 queue&lt;pair&lt;int, int>> Q; Q.push({ 0, 0 }); vis[0][0] = 0; //무조건 시작점은 좌상단 0, 0임 while (!Q.empty()) { auto cur = Q.front(); //auto 키워드는 선언한 변수나 람다식의 타입을 컴파일러에게 추론하도록 맡김 //약간 카멜레온 느낌 알아서 바뀜 Q.pop(); for (int dir = 0; dir &lt; 4; dir++) { int nx = cur.X + dx[dir]; int ny = cur.Y + dy[dir]; //현재 위치에서 와리가리 하려고 if (nx &lt; 0 || ny &lt; 0 || nx >= n || ny >= m) continue; //nx, ny가 범위를 벗어날 경우 continue함 if (vis[nx][ny] >= 0 || str_board[nx][ny] != '1') continue; //vis나 str_board에 1이나 시작점부터의 거리가 표시 되있으면 continue함 vis[nx][ny] = vis[cur.X][cur.Y] + 1; //현재의 위치 = (현재의 상하좌우 기준점)보다 한칸 더 앞에 있으므로 +1을 하여 저장함. Q.push({ nx, ny }); } } cout &lt;&lt; vis[n-1][m-1] + 1; //문제에서는 (0,0)이 시작이 아니라 (1, 1)을 시작이라 하기 때문에 [-1]을 해줘야 함 //+1을 한 이유는 0,0을 0으로 잡고 시작했기 때문에 거리를 계산할때 첫번째 칸을 1이 아닌 0으로 잡고 시작하기 때문에 +1해서 표현함. return 0; } //BOJ-7576 토마토 #include&lt;iostream> #include&lt;bits/stdc++.h> #include&lt;string> #include&lt;queue> #define X first #define Y second using namespace std; int board[1005][1005]; int vis[1005][1005]; int dx[4] = { 1, 0, -1, 0 }; int dy[4] = { 0, 1, 0, -1 }; int main() { int m, n, num = 0; cin >> m >> n; queue&lt;pair&lt;int, int>> Q; for (int i = 0; i &lt; m; i++) //입력 for (int j = 0; j &lt; n; j++) { cin >> board[i][j]; if (board[i][j] == 1)//익은 토마토인지 판별 { Q.push({ i, j }); //익은 토마토 있으면 큐에 넣기 vis[i][j] = 0; //익은 애들은 0 } else if (board[i][j] == 0) vis[i][j] = -1; } while (!Q.empty()) { pair&lt;int, int> cur = Q.front(); //토마토가 위치한 곳을 cur에 넣어 상하좌우로 탐색 //여기서 front의 반환값은 입력을 기준으로 첫번째로 익은 애들을 좌표에 넣음 그 다음 2번째... 끝까지 진행.. Q.pop();//메모리 초과, 시간 초과가 날 수 있기 때문에 빠딱빠딱 빼줘야 됨 for (int dir = 0; dir &lt; 4; dir++)//상하좌우 탐색을 위해 반복 { int nx = cur.X + dx[dir]; int ny = cur.Y + dy[dir]; if (nx &lt; 0 || nx >= m || ny &lt; 0 || ny >= n) continue; //범위에서 벗어나는 겨우 continue if (vis[nx][ny] >= 0) continue; //이미 방문한 경우이거나 토마토가 익어 있지 않은 경우 vis[nx][ny] = vis[cur.X][cur.Y] + 1; //좌표값에 해당 좌표에 있는 값 +1을 하여 누적 시켜줌. ==> 날짜 증가 Q.push({ nx, ny }); } } for (int i = 0; i &lt; m; i++)//이중 for문으 사용하여 -1이 하나라도 있는 지 확인하고, 좌표 값 가장 큰값을 찾는 것이다. { for (int j = 0; j &lt; n; j++) { if (vis[i][j] == -1) //익지 않은 토마토가 아직 존재한다는 소리이므로 조건대로 -1출력 { cout &lt;&lt; -1; return 0; } num = max(num, vis[i][j]); } } cout &lt;&lt; num; //아직 익지 않은 토마토가 없으므로 최소 일수 출력. return 0; } //BOJ-1926 그림 #include &lt;bits/stdc++.h> #include &lt;iostream> #include &lt;queue> #define X first #define Y second using namespace std; int n, m; int area = 0, mx = 0, num = 0; int board[502][502] = {}; bool vis[502][502]; int dx[4] = { 1, 0, -1, 0 }; int dy[4] = { 0, 1, 0, -1 }; int main() { ios::sync_with_stdio(0); cin.tie(0); cin >> n >> m; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) cin >> board[i][j]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (board[i][j] == 0 || vis[i][j]) continue; num++; //그림의 개수 증가 queue&lt;pair&lt;int, int>> Q; Q.push({i , j});//새로운 그림의 시작점 표기라고 봐도 됨 vis[i][j] = 1; //while 들어가기 전 시작점 표시 크게 보면 다른 그림의 새로운 시작점 표시 area = 0; while (!Q.empty()) { area++; //그림의 넓이 증가 pair&lt;int, int> cur = Q.front(); Q.pop(); for (int dir = 0; dir &lt; 4; dir++) //상하좌우로 이어지는 그림이 있나 확인하기 위해 반복 { int nx = dx[dir] + cur.X; int ny = dy[dir] + cur.Y; if (nx &lt; 0 || ny &lt; 0 || nx >= n || ny >= m) continue; if (vis[nx][ny] || board[nx][ny] != 1) continue; vis[nx][ny] = 1; Q.push({ nx, ny }); } } mx = max(area, mx); } } cout &lt;&lt; num &lt;&lt; '\n' &lt;&lt; mx; return 0; }</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/unorderedmap/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">Unordered_map 개념
map 보다 더 빠른 탐색을 하기 위한 자료구조의 종류이다. unorderd_map은 해쉬테이블로 구현한 자료구조이며 시간복잡도는 O(1)이다. 우리가 흔히 사용하는 일반적인 map은 Binary Search Tree로 시간복잡도는 O(logN)이다. unorderd_map은 중복된 데이터를 허용하지 않고 map에 비해 데이터가 많을 시 출동을 방지하며 좋은 성능을 보인다. 멤버함수</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/tree/%EC%98%88%EC%8B%9C%EC%BD%94%EB%93%9C/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">예시 코드 //BFS 예시 코드1 - 부모 배열 채우기 #include &lt;iostream> #include &lt;vector> #include &lt;queue> using namespace std; void bfs() { int root; cin >> root; vector&lt;int> adj[10]; int p[10]; queue&lt;int> q; q.push(root); while (!q.empty()) { int cur = q.front(); q.pop(); for (auto nxt : adj[cur]) { if (p[cur] == nxt) continue; q.push(nxt); p[nxt] = cur; //자식 노드의 부모 노드를 재방문해서 다른 곳으로 새는 것을 막기 위함 기존의 BFS와의 차이 } } } //BFS 예시 코드2 - 부모와 depth 배열 채우기 #include &lt;iostream> #include &lt;vector> #include &lt;queue> using namespace std; //시간 복잡도는 동일 O(V+E)이며 트리에서는 E = V - 1이기에 O(V)가 됨 //vis를 이용할 때와 코드의 흐름은 큰 차이는 없음 vis의 용도를 바꾸기 위해 bool형이 아닌 int형의로 해당 칸에서의 왔던 길?을 체크해주기 때문 //예시 코드1과는 큰 차이가 없음 추가된 것은 depth를 활용하여 거리를 측정하는 것 void bfs() { int root; cin >> root; vector&lt;int> adj[10]; int p[10]; //P배열의 용도는 부모 노드를 재방문해서 왔던 길로 다시 돌아가지 않게 하기 위함 int depth[10]; queue&lt;int> q; q.push(root); while (!q.empty())//BFS의 일반적인 틀 { int cur = q.front(); q.pop(); cout &lt;&lt; cur &lt;&lt; ' '; for (auto nxt : adj[cur]) { if (p[cur] == nxt) continue; q.push(nxt); p[nxt] = cur; //자식 노드의 부모 노드를 재방문해서 다른 곳으로 새는 것을 막기 위함 기존의 BFS와의 차이 depth[nxt] = depth[cur] + 1; //root에서부터 부모 노드의 거리 + 1 = root에서부터 현재 노드까지의 거리 } } } #include &lt;iostream> #include &lt;stack> #include &lt;vector> using namespace std; //DFS 예시 코드1 - 부모와 depth 배열 채우기, 비재귀 //기존 BFS 예시 코드와의 차이는 크게 없다. queue을 stack으로 바꾸면 된다. void dfs() { int root; cin >> root; vector&lt;int> adj[10]; int p[10]; //P배열의 용도는 부모 노드를 재방문해서 왔던 길로 다시 돌아가지 않게 하기 위함 int depth[10]; stack&lt;int> s; s.push(root); while (!s.empty())//BFS의 일반적인 틀 { int cur = s.top(); s.pop(); cout &lt;&lt; cur &lt;&lt; ' '; for (auto nxt : adj[cur]) { if (p[cur] == nxt) continue; s.push(nxt); p[nxt] = cur; //자식 노드의 부모 노드를 재방문해서 다른 곳으로 새는 것을 막기 위함 기존의 BFS와의 차이 depth[nxt] = depth[cur] + 1; //root에서부터 부모 노드의 거리 + 1 = root에서부터 현재 노드까지의 거리 } } } #include &lt;iostream> #include &lt;stack> #include &lt;vector> using namespace std; //DFS 예시 코드2 - 부모와 depth 배열 채우기, 재귀 //기존 BFS 예시 코드와의 차이는 크게 없다. queue을 stack으로 바꾸면 된다. vector&lt;int> adj[10]; int p[10]; //P배열의 용도는 부모 노드를 재방문해서 왔던 길로 다시 돌아가지 않게 하기 위함 int depth[10]; void dfs(int cur) { cout &lt;&lt; cur &lt;&lt; ' '; for (auto nxt : adj[cur]) { if (p[cur] == nxt) continue; p[nxt] = cur; //자식 노드의 부모 노드를 재방문해서 다른 곳으로 새는 것을 막기 위함 기존의 BFS와의 차이 depth[nxt] = depth[cur] + 1; //root에서부터 부모 노드의 거리 + 1 = root에서부터 현재 노드까지의 거리 dfs(nxt); } } //재귀로 구현시 코드는 상당히 깔끔해짐. 하지만 스택 메모리가 1MB로 제한되어 있을 땐 V가 대략 3만 이상일 때 1-2-3-4-5-6 //형태의 일자 트리 모양에서 스택 메모리 한계를 넘어설 수 있기때문에 스택 메모리에 대한 별도의 제한이 있을 때에는 주의해야 함 //DFS 예시 코드3 - 단순 순회, 재귀 #include &lt;iostream> #include &lt;stack> #include &lt;vector> using namespace std; vector&lt;int> adj[10]; int p[10]; //P배열의 용도는 부모 노드를 재방문해서 왔던 길로 다시 돌아가지 않게 하기 위함 int depth[10]; void dfs(int cur, int par) { cout &lt;&lt; cur &lt;&lt; ' '; for (auto nxt : adj[cur]) { if (par == nxt) continue; dfs(nxt, cur); } } //call dfs(1, 0);</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/tree/%EA%B0%9C%EB%85%90/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">개념 트리의 정의 : 무방향이면서 사이클이 없는 연결 그래프(Undirected Acyclic Connected Graph), 그래프의 한 종류라고 함. 앞서 배운 stack, queue, list 등과는 다르게 선형이 아니라 **계층적인 구조(hierarchical structure)**를 가지고 있다.</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/tree/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">Tree 개념
예시 코드
//BOJ - 11725 - 트리의 부모 찾기 #include &lt;iostream> #include &lt;vector> #include &lt;queue> using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0); int n, node1, node2;//정점의 개수 int p[1000001] = {}; vector&lt;int> v[1000001]; queue&lt;int> q; cin >> n; for (int i = 0; i &lt; n - 1; i++) { cin >> node1 >> node2; v[node1].push_back(node2); v[node2].push_back(node1); } q.push(1); while (!q.empty()) { int cur = q.front(); q.pop(); for (auto nxt : v[cur]) { if (p[cur] == nxt) continue; q.push(nxt); p[nxt] = cur; } } for (int i = 2; i &lt;= n; i++) cout &lt;&lt; p[i] &lt;&lt; '\n'; return 0; } //BOJ - 1991 - 트리 순회 #include &lt;iostream> #include &lt;vector> #include &lt;queue> using namespace std; int lc[300]; //left child int rc[300];//right child void preorder(int cur) { cout &lt;&lt; (char)cur; if (lc[cur] != 0) preorder(lc[cur]); if (rc[cur] != 0) preorder(rc[cur]); } void Inorder(int cur) { if (lc[cur] != 0) Inorder(lc[cur]); cout &lt;&lt; (char)cur; if (rc[cur] != 0) Inorder(rc[cur]); } void Postorder(int cur) { if (lc[cur] != 0) Postorder(lc[cur]); if (rc[cur] != 0) Postorder(rc[cur]); cout &lt;&lt; (char)cur; } int main() { //root = A int n; char node1, node2, node3; cin >> n; for (int i = 0; i &lt; n; i++) { cin >> node1 >> node2 >> node3; if (node2 != '.') lc[node1] = node2; if (node3 != '.') rc[node1] = node3; } preorder('A'); cout &lt;&lt; '\n'; Inorder('A'); cout &lt;&lt; '\n'; Postorder('A'); }</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/recursion/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">재귀 (Recursion) BOJ_1629 곱셈 #include &lt;iostream> #define ll long long using namespace std; ll Recur(ll A, ll B, ll C) { if (B == 1) return A % C; //Base Condition ll remainder = Recur(A, B / 2, C); if (B % 2 == 0) return remainder * remainder % C; //짝수인 경우 else //홀수인 경우 { //return remainder * remainder * A % C; //이유는 reaminder의 최대값은 int 양의 최대값 -1, 대략적으로 10^9이고 이 두 수를 곱하면 최소 10^18 //long long의 범위는 10^18이므로, reaminder의 제곱에 A를 곱할 경우 높은 확률로 오버플로우가 발생 remainder = remainder * remainder % C; return remainder * A % C; } } int main(void) { ios::sync_with_stdio(false); cin.tie(NULL); ll A, B, C; cin >> A >> B >> C; cout &lt;&lt; Recur(A, B, C); } //BOJ - 1074 Z 바킹독(수정해야함) //이해는 했지만 내가 생각했던 거랑은 좀 다름 #include &lt;iostream> #include&lt;algorithm> using namespace std; //사분면을 거르고 함수를 호출할 때마다 n-1을 하는 이유 : 2의 N승이니까 사각형을 2의 (N / 2)승으로 만들기 위함 // 이 과정을 Base Condition에 도달?할 때까지 함 int func(int n, int r, int c) { if (n == 0) return 0; //Base Condition에 도달했다는 것은 r, c까지 도달했다는 소리이므로 return 시작. int half = 1 &lt;&lt; (n - 1); //비트 연산자 if (r &lt; half && c &lt; half) return func(n - 1, r, c); //1번 사각형인 경우 if (r &lt; half && c >= half) return half * half + func(n - 1, r, c - half); //2번 사각형인 경우 if (r >= half && c &lt; half) return 2 * half * half + func(n - 1, r - half, c);//3번 사각형인 경우 return 3 * half * half + func(n - 1, r - half, c - half); } int main() { ios::sync_with_stdio(0); cin.tie(0); int n, r, c; cin >> n >> r >> c; cout &lt;&lt; func(n, r, c); } //예시 1번 2 1 3 /* * 1. 3번 사각형 (R, C) = (3, 1) * half 1 &lt;&lt; (2 - 1) ====>> 1을 1만큼 왼쪽으로 비트 이동 시키면 0001에서 0010으로 바뀐다. 그러므로 half = 2이다. if(3 >= 2 && 1 &lt; 2) return 8 + func(1, 1, 1) 여기서 func의 호출은 타고 들어가는 느낌이다. 여기서 호출한 func의 리턴 값 + 8이 답인 것이다. 8 + 3(코드38번째 줄의 리턴 값) = 11이므로 최종적으로 11을 return 해준다. 2. 4번 사각형 (R, C) = (1, 1) half 1 &lt;&lt; (1 - 1) ====>> 1을 0만큼 왼쪽으로 비트 이동은 암것도 없으므로 half = 1이다 if(1 >= 1 && 1 >= 1) return 3 * half * half + func(0, 0, 0) 3 + 0(코드40번째 줄의 리턴 값) 3.BaseCondition 조건문이 참이 되므로 return 0; 0의 값은 38번째 줄로 감. */ //BOJ - 11729 하노이 탑 이동 순서 (이해 X) #include &lt;iostream> using namespace std; /* * 1. n-1개의 원판을 기둥1 -> 기둥2 * 2. n번 원판을 기둥1 -> 기둥3 * 3. n-1개의 원판을 기둥2 -> 기둥3 * * 재귀식 * n-1개의 원판을 기둥 a -> 기둥 6 - a - b * n번 원팔을 기둥a -> 기둥b * n-1개의 원판을 기둥6-a-b -> b */ void func1(int a, int b, int n) { if (n == 1) //Base Condition { cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\n'; return; } func1(a, 6 - a - b, n - 1); cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; '\n'; func1(6 - a - b, b, n - 1); } int main() { int n; cin >> n; cout &lt;&lt; (1 &lt;&lt; n) - 1 &lt;&lt; '\n'; func1(1, 3, n); } //BOJ - 17478 - 재귀함수가 뭔가요? //띄어쓰기 못 찾아서 이틀을 어리바리... #include &lt;iostream> using namespace std; int i = 0; bool plag, plag2; void func1(int n) { if (n == 0) plag = true; //"라고 답변하였지."이라는 텍스트가 출력 되기 전까지를 체크하고 n번 반복하기 위함 if (!plag) { for (int j = 0; j &lt; i; j++) cout &lt;&lt; "____"; //_(4개)의 반복횟수는 함수의 호출횟수와 동일하므로 i로 호출횟수를 체크하여 반복 cout &lt;&lt; "\"재귀함수가 뭔가요?\"\n"; for (int j = 0; j &lt; i; j++) cout &lt;&lt; "____"; cout &lt;&lt; "\"잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을 통달한 선인이 있었어.\n"; for (int j = 0; j &lt; i; j++) cout &lt;&lt; "____"; cout &lt;&lt; "마을 사람들은 모두 그 선인에게 수많은 질문을 했고, 모두 지혜롭게 대답해 주었지.\n"; for (int j = 0; j &lt; i; j++) cout &lt;&lt; "____"; cout &lt;&lt; "그의 답은 대부분 옳았다고 하네. 그런데 어느 날, 그 선인에게 한 선비가 찾아와서 물었어.\"\n"; } else//n번의 반복이 끝났으면 "라고 답변하였지." 텍스트를 반복하기 위해 return { return; } i++;//_*4개 출력을 제어하기 위함 func1(--n);//n번 반복하기 위해 호출할 때마다 -1을 해줌 if (plag) //n번의 반복이 끝났다면 실행. { if (!plag2) { for (int j = 0; j &lt; i; j++) cout &lt;&lt; "____"; cout &lt;&lt; "\"재귀함수가 뭔가요?\"\n"; for (int j = 0; j &lt; i; j++) cout &lt;&lt; "____"; cout &lt;&lt; "\"재귀함수는 자기 자신을 호출하는 함수라네\"\n"; for (int j = 0; j &lt; i; j++) cout &lt;&lt; "____"; cout &lt;&lt; "라고 답변하였지.\n"; plag2 = true;////"재귀함수가 뭔가요?", "재귀함수는 자기 자신을 호출하는 함수라네" 라는 멘트는 딱 한 번만 출력 되어야 하므로 이 멘트를 출력하였으면 plag2에 true를 표시해주어 중복 출력을 방지함 i--; } else { for (int j = 0; j &lt; i; j++) cout &lt;&lt; "____"; cout &lt;&lt; "라고 답변하였지.\n"; i--; } } } int main() { int n; cin >> n; cout &lt;&lt; "어느 한 컴퓨터공학과 학생이 유명한 교수님을 찾아가 물었다.\n"; //시작멘트 func1(n); cout &lt;&lt; "라고 답변하였지."; //문제에서 입력의 범위를 1부터라고 말했으므로 함수가 종료된 이후에 호출 되도 무관함 return 0; } //BOJ - 11729 하노이 탑 이동 순서 #include &lt;iostream> using namespace std; /* * 1. n-1개의 원판을 기둥1 -> 기둥2 * 2. n번 원판을 기둥1 -> 기둥3 * 3. n-1개의 원판을 기둥2 -> 기둥3 * * 재귀식 * n-1개의 원판을 기둥 a -> 기둥 6 - a - b * n번 원팔을 기둥a -> 기둥b * n-1개의 원판을 기둥6-a-b -> b * * 설명 들어보기 들어도 이해가 잘 안됨. */ void func1(int a, int b, int n) { if (n == 1) //Base Condition { cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\n'; return; } func1(a, 6 - a - b, n - 1); cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; '\n'; func1(6 - a - b, b, n - 1); } int main() { int n; cin >> n; cout &lt;&lt; (1 &lt;&lt; n) - 1 &lt;&lt; '\n'; func1(1, 3, n); } //재귀 Recursion #include&lt;iostream> using namespace std; // recursion(재귀) /* * : 하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘 * * 수학적 귀납법 : 1번 도미노가 쓰러짐 -> K번 도미노가 쓰러진다 -> K+1번 도미노가 쓰러지므로 참이다. * , 우리는 이러한 것으로 1번 쓰러짐 and K번 도미노가 쓰러짐 = 모든 도미노가 쓰러진다 라는 결론을 도출할 수 있음 * * 올바른 재귀 조건 * 1.특정 입력에 대해서는 자기 자신을 호출하지 않고 종료 되어야 한다. (Base Condition) * 2.모든 입력은 Base Condition으로 수렴해야 한다. * * 재귀 함수는 꽤 비용이 큰 연산이므로 메모리와 시간에서는 큰 손해를 본다. * * 재귀 작성 요령 * 1. 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함 * 2. 모든 재귀함수는 반복문으로 동일한 동작을 하는 함수를 만들 수 있음 * 3. 한 함수가 자기 자신을 여러 번 호출하면 비효율적일 수 있음 -> 37번째 줄 참고(피보나치 함수) * */ void func1(int N) { if (N == 0) //Base condition return; func1(N--); } int func2(int N) { if (N == 0) return 0; return N + func2(N - 1); } int fibo(int n) { if (n &lt;= 1) return 1; return fibo(n - 1) + fibo(n - 2); //이 재귀는 시간복잡도가 지수함수 꼴로 터짐 //왜냐? 이미 연산한 것을 반복함 향후 DP로 해결 가능한 부분도 존재 } int main() { int n; cin >> n; func1(n); func2(n); cout &lt;&lt; n; return 0; }</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/priorityqueue/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">Priority_Queue(우선순위 큐) 개념
Heap 자료구조를 응용한 대표적인 사례가 Priority_Queue(우선순위 큐)이다. Prioriy Queue는 queue의 한 종류로 이름 그대로 우선순위에 따라 정렬된 Queue이다. 어떤 원소가 push되면 주어진 우선순위에 맞춰서 Queue가 정렬되고, pop은 정렬된 Queue의 앞에서 이루어진다. 자료구조 Heap으로 구현되었기 때문에, 특정 운소를 push해 생기는 정렬 과정은 시간복잡도 O(log N)만에 이루어진다. 우선순위 큐는 배열, 연결리스트 등의 여러 가지 방법으로 구현이 가능하지만 가장 효율적인 구조는 heap이다. 우선순위 큐는 삭제 연산에서 어떤 요소가 먼저 삭제되는가에 따라 최소 우선순위 큐와 최대 우선위 큐로 나누어진다 최대 우선순위 큐는 우선순위가 가장 높은 요소가 먼저 삭제된다. 최소 우선순위 큐는 우선순위가 가장 낮은 요소가 먼저 삭제된다. 구현 방법</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/map/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">Map 개념
map contaniner는 노드 기반으로 이루어져 있는 균형 이진 트리 구조이다. map은 key와 value로 이루어져 있으며 pair 객체 형태로 저장된다. Unique Key : key는 고유한 값이므로 중복이 불가능하다.(만약 중복 key를 사용하고 싶다면 multimap에서 사용 가능) Ordered - map도 set과 마찬가지로 삽입이 되면서 자동으로 정렬이 된다. (default는 less/오름차순이다.) https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F25B9D333597A9D5623</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/heap/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">Heap 개념
https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVCP5n%2FbtqSPE4E2hn%2F2G7f8scOqnpXFfJEN0bZLk%2Fimg.png
→ heap은 이진 트리 자료구조이다.
→ i번째 노드의 자식 노드는 i * 2 + 1번째 노드와 i * 2 + 2번째 노드가 된다.</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a><a href=/ko/study/problemsolving/datastructure/graph/ class=mb-5><div class=md:flex><div class="md:flex-shrink-0 overflow-hidden"></div><div class=p-8><div class="uppercase tracking-wide text-md text-primary-700 dark:text-primary-200 font-semibold"></div><p class="block mt-1 text-sm leading-tight font-medium text-black dark:text-white">Graph 예시 코드
//방향 그래프(Directed Graph, 인접행렬) #include&lt;iostream> #include&lt;bits/stdc++.h> //방향 그래프(Directed Graph) using namespace std; int main() { int node , Edge; //정점과 간선의 개수 int adj_matrix[100][100]; cin >> node >> Edge; for (int i = 0; i &lt; Edge; i++) { int u, v; cin >> u >> v; adj_matrix[u][v] = 1; } } #include &lt;iostream> #include &lt;bits/stdc++.h> #include &lt;vector> #include &lt;queue> using namespace std; int board[1005][1005]; bool vis1[1005]; //DFS bool vis2[1005]; //BFS int main() { int n, m, v; //정점의 개수, 간선의 개수, 탐색을 시작할 정점의 번호 int V, node; //정점1, 정점2 int cnt = 0; cin >> n >> m >> v; vector&lt;int> adj_v[1005]; //BFS를 돌릴 큐 vector&lt;int> adj_q[1005]; //DFS를 돌릴 큐 queue&lt;int> Q1;//DFS queue&lt;int> Q2;//BFS for (int i = 0; i &lt; m; i++) //문제에서 간선의 방향은 양방향이라고 주어짐. { cin >> V >> node; adj_v[V].push_back(node); adj_v[node].push_back(V); //무방향 그래프의 BFS를 위함. adj_q[V].push_back(node); adj_q[node].push_back(V); //무방향 그래프의 DFS를 위함. } Q1.push(v);//시작 정점을 큐에 넣음 vis1[v] = 1; //방문했다는 표시를 남겨줌 while (!Q1.empty()) //DFS 시작 { int num = 100000; //DFS에서 가장 번호가 작은 노드를 찾기 위해 사용될 변수 int cur = Q1.front(); cout &lt;&lt; cur &lt;&lt; ' '; Q1.pop(); for (int nxt : adj_q[cur])//인접한 노드 중에 가장 작은 노드를 방문(단순하게 숫자가 작은 노드를 말함) { if (vis1[nxt]) continue; //이미 방문한 노드인 경우 continue num = min(num, nxt); //가장 작은 값을 찾음 } if (num >= 100000) continue; //예외처리하라고 문구 뜨길래 넣어줌 Q1.push(num); //가장 작은 노드 방문을 위해 큐에 값을 넣음 vis1[num] = 1;//방문했다는 표시를 남김 } cout &lt;&lt; '\n'; Q2.push(v);//시작 정점을 큐에 넣음 vis2[v] = 1; //방문했다는 표시를 남겨줌 while (!Q2.empty()) //BFS 시작 { int num = 100000; //가장 작은 녿 int cur = Q2.front(); cout &lt;&lt; cur &lt;&lt; ' '; Q2.pop(); sort(adj_v[cur].begin(), adj_v[cur].end()); //동일한 거리에서 낮은 번호의 노드부터 출력해야 하므로 정렬 for (int nxt : adj_v[cur])//거리를 기반으로 같은 거리에 존재하는 것들 먼저 출력. begin { if (vis2[nxt]) continue; //이미 방문한 노드인 경우 continue Q2.push(nxt);//바로 인접한 노드(현재 노드를 기준으로 거리 = 1)를 큐에 넣는다 vis2[nxt] = true; } } return 0; } //DFS-개념 #include &lt;bits/stdc++.h> #include &lt;iostream> #include &lt;stack> using namespace std; #define X first #define Y second // pair에서 first, second를 줄여서 쓰기 위해서 사용 int board[502][502] = { {1,1,1,0,1,0,0,0,0,0}, {1,0,0,0,1,0,0,0,0,0}, {1,1,1,0,1,0,0,0,0,0}, {1,1,0,0,1,0,0,0,0,0}, {0,1,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0} }; // 1이 파란 칸, 0이 빨간 칸에 대응 bool vis[502][502]; // 해당 칸을 방문했는지 여부를 저장 int n = 7, m = 10; // n = 행의 수, m = 열의 수 int dx[4] = { 1,0,-1,0 }; int dy[4] = { 0,1,0,-1 }; // 상하좌우 네 방향을 의미 int main(void) { ios::sync_with_stdio(0); cin.tie(0); stack&lt;pair&lt;int, int> > S; vis[0][0] = 1; // (0, 0)을 방문했다고 명시 S.push({ 0,0 }); // 스택에 시작점인 (0, 0)을 삽입. ~~~~while (!S.empty()) { pair&lt;int, int> cur = S.top(); S.pop(); //메모리초과, 시간초과를 방지하기 위해 pair변수에 넣어주고 바로 pop() 해주는 과정을 거침 cout &lt;&lt; '(' &lt;&lt; cur.X &lt;&lt; ", " &lt;&lt; cur.Y &lt;&lt; ") -> "; for (int dir = 0; dir &lt; 4; dir++) { // 상하좌우 칸을 살펴볼 것이다. int nx = cur.X + dx[dir]; int ny = cur.Y + dy[dir]; // nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감 if (nx &lt; 0 || nx >= n || ny &lt; 0 || ny >= m) continue; // 범위 밖일 경우 넘어감 if (vis[nx][ny] || board[nx][ny] != 1) continue; // 이미 방문한 칸이거나 파란 칸이 아닐 경우 vis[nx][ny] = 1; // (nx, ny)를 방문했다고 명시 S.push({ nx,ny });//깊이 우선 탐색을 위해 nx와 ny의 좌표를 push함 } } } //무방향 그래프(Undirected Graph, 인접행렬) #include&lt;iostream> #include&lt;bits/stdc++.h> //무방향 그래프(Undirected Graph) using namespace std; int main() { int node , Edge; //정점과 간선의 개수 int adj_matrix[100][100]; cin >> node >> Edge; for (int i = 0; i &lt; Edge; i++) { int u, v; cin >> u >> v; adj_matrix[u][v] = 1; adj_matrix[v][u] = 1; } } //방향 그래프(Directed Graph, 인접 리스트) #include&lt;iostream> #include&lt;bits/stdc++.h> #include&lt;vector> //방향 그래프(Directed Graph) using namespace std; int main() { int node , Edge; //정점과 간선의 개수 vector &lt;int> adj_matrix[100]; cin >> node >> Edge; for (int i = 0; i &lt; Edge; i++) //간선의 개수만큼 반복 { int u, v; cin >> u >> v; adj_matrix[u].push_back(v); } } //무방향 그래프(Undirected Graph, 인접 리스트) #include&lt;iostream> #include&lt;bits/stdc++.h> #include&lt;vector> //무방향 그래프(Directed Graph) using namespace std; int main() { int node , Edge; //정점과 간선의 개수 vector &lt;int> adj_matrix[100]; cin >> node >> Edge; for (int i = 0; i &lt; Edge; i++) { int u, v; cin >> u >> v; adj_matrix[u].push_back(v); adj_matrix[v].push_back(u); } } //BOJ-11724 연결 요소의 개수 #include &lt;iostream> #include &lt;bits/stdc++.h> #include &lt;vector> #include &lt;queue> using namespace std; bool vis[100005]; int main() { int cnt = 0; int n, m; //정점의 개수와 간선의 개수 int u, v; //간선의 양 끝점 u v vector&lt;int> adj[100005]; queue&lt;int> Q; cin >> n >> m; for (int i = 0; i &lt; m; i++) { cin >> u >> v; //간선을 기준으로 양 끝점 u와 v를 입력 받음 adj[u].push_back(v); adj[v].push_back(u); //문제에서 방향 없는 그래프라고 했으므로 무방향 그래프이므로 adj[u], adj[v]에 각각 push_back 함 } for (int i = 1; i &lt;= n; i++)//각 정점을 돌며 연결을 확인해야 하므로 정점의 개수만큼 반복 { if (vis[i])//방문한 곳이면 true { cnt++;//연결이 끊어진 경우 cnt continue; //방문한 경우 넘어간다 } Q.push(i);//32번째 if문에서 걸러지지 않았으므로 방문하지 않았으니 i와 연결된 정점들을 체크해보기 위해 Q에 push vis[i] = true; //방문한 곳을 또 방문하지 않기 위해 표시를 남김 while (!Q.empty()) //연결된 모든 지점을 방문한다. { int cur = Q.front();//큐에서 정점을 꺼내어 그 정점과 연결된 모든 정점들에 대해 3번을 진행 Q.pop();//시간초과 or 런타임에러가 발생할 수도 있으니 바로 빼줘야 함 자주하는 실수 중 하나라고 강조 for (int nxt : adj[cur])//nxt = adj배열의 내부 값을 가지고 반복 횟수는 adj[cur]의 요소 개수만큼 반복함 { if (vis[nxt]) continue; //이미 방문한 경우 continue 이 말은 즉, 연결이 되었는 지 확인한 경우를 말한다 Q.push(nxt);//방문하지 않은 곳이므로 Q에 넣고 43번째의 while문을 수행한다. vis[nxt] = true;//방문한 곳을 또 방문하지 않기 위해 표시를 남김 } } } cout &lt;&lt; n - cnt; //정점의 개수에서 continue한 횟수를 빼면 연결이 끊긴 횟수를 알 수 있다. return 0; } //Graph(BFS) - 연결 그래프에서의 순회 #include &lt;iostream> #include &lt;bits/stdc++.h> #include &lt;vector> #include &lt;queue> using namespace std; int main() { vector&lt;int> adj[10]; bool vis[10]; queue&lt;int> q; q.push(1);//시작하는 정점을 큐에 넣고 vis[1] = true;//방문했다는 표시를 남김 //과정1번 while (!q.empty()) { int cur = q.front();//큐에서 정점을 꺼내어 그 정점과 연결된 모든 정점들에 대해 과정 3번 진행 q.pop();//시간초과 or 런타임 에러를 방지하기 위해 넣어줬으면 바로 빼줘야 됨 //과정2번 cout &lt;&lt; cur &lt;&lt; ' '; for (auto nxt : adj[cur]) //해당 vector [cur]번째에 들어있는 요소의 개수만큼 반복하고 그 값을 nxt에 넣으면서 진행됨 { if (vis[nxt]) continue; //이미 방문한 곳이면 continue함 q.push(nxt);//큐에 push하여 현재 nxt와 연결된 곳을 탐색 vis[nxt] = true;//방문하였으므로 중복되어 시간초과가 발생하지 않게 방문표시를 남겨줌 }//과정3번 } } //인접리스트에서는 시간 복잡도 O(V+E), 인접행렬에서는 시간 복잡도O(V^2)이다 //BOJ - 2606 - 바이러스 #include &lt;iostream> #include &lt;vector> #include &lt;queue> using namespace std; //이 문제에서 방향과 상관없이 연결된 모든 것은 감염된다. 이는 무방향 그래프를 말해준다. bool vis1[1005]; //방문여부를 확인하기 위한 bool형 int main() { int n; //컴퓨터의 개수 int node1, node2, edge; //정점1과 정점2, 쌍의 개수를 의미함 int cnt = 0; //바이러스에 감염된 컴퓨터의 수 = 총 컴퓨터의 수 - 감염되지 않은 컴퓨터의 수 cin >> n >> edge; vector&lt;int> V1[105]; queue&lt;int> Q1; for (int i = 0; i &lt; edge; i++) { cin >> node1 >> node2; V1[node1].push_back(node2); V1[node2].push_back(node1); //무방향 그래프이므로 둘다 push_back해줌 } Q1.push(1);//시작할 정점을 큐에 넣음 vis1[1] = 1; //방문표시를 남겨줌. while (!Q1.empty()) { int cur = Q1.front();//정점을 꺼내어 그 정점과 연결된 모든 정점들을 찾기 위함 Q1.pop(); for (auto nxt : V1[cur]) { if (vis1[nxt] == 1) continue; //이미 방문했다면 continue하는 것 Q1.push(nxt);//인접 리스트 안에 있는 숫자 중에 방문하지 않은 숫자이므로 방문하여 nxt와 연결 되어 있는 컴퓨터들을 감염 vis1[nxt] = 1; //방문했으므로 다시 방문하지 않게 감염표시를 남겨줌 } } for (int i = 1; i &lt;= n; i++) { if (vis1[i] == 0) cnt++; //감염되지 않은 컴퓨터의 수를 파악하기 위함 } cout &lt;&lt; n - cnt - 1; //if (vis[i] == 0)의 구절을 옮기면 더 줄일 수 있음 } //BOJ - 5567 - 결혼식 #include &lt;iostream> #include &lt;vector> #include &lt;queue> using namespace std; //ai와 bi가 친구라는 뜻이며, bi와 ai도 친구관계이다. 이 말은 즉슨 무방향 그래프를 말한다 bool vis[10005]; int main() { int n, m;// 상근이의 동기의 수, 리스트의 길이 int a, b; //친구 관계 int cnt = 0, count = 0; cin >> n >> m; vector&lt;int> v[505]; queue&lt;int> q; for (int i = 0; i &lt; m; i++)//상근이의 리스트의 길이만큼 반복 { cin >> a >> b; v[a].push_back(b); v[b].push_back(a); //친구 관계를 입력 받고 무방향 그래프이므로 양쪽에게 모두 넣어줌. } q.push(1); //시작점(상근이)를 큐에 넣고 상근이의 친구를 탐색한다. vis[1] = 1; //친구인 것을 인증하고 난 이후 또 친구인지 아닌지 확인하지 않기 위함 while (!q.empty()) { int cur = q.front(); q.pop(); //시간초과 or 런타임 에러를 방지하기 위해 cur에 front값을 넣어줬으면 다시 사용하지 않기 때문에 바로 빼줘야 함 if (cur == 1) //상근이와 직접 친구 관계인 사람들을 위한 BFS { for (auto nxt : v[cur]) { if (vis[nxt] == 1) continue; q.push(nxt); vis[nxt] = 1; cnt++; //상근이와의 직속? 친구 관계인 사람들의 수를 구함. count++; //이는 BFS } } else if (cnt != 0)//상근이와의 친구의 친구인지를 확인할 BFS { for (auto nxt : v[cur]) { if (vis[nxt] == 1) continue; vis[nxt] = 1; count++; } cnt--; } } cout &lt;&lt; count; return 0; } 개념</p><p class="mt-2 text-gray-500 dark:text-gray-400 text-sm">1월 1, 0001</p></div></div></a></div><nav class=mt-1><ul class="container mx-auto flex justify-center"><li class=p-5><a class=page-link href=/ko/study/problemsolving/page/2/>다음 &#187;</a></li></ul></nav></div></div><div class=page-footer><footer class="container mx-auto flex flex-col justify-items-center text-sm leading-6 mt-24 mb-4 text-slate-700 dark:text-slate-200"><div class="mx-auto flex gap-3 py-2 px-4"><div class=font-bold><svg class="inline-block pr-1" style="height:1em" viewBox="0 0 24 24"><path fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 21a9.004 9.004.0 008.716-6.747M12 21a9.004 9.004.0 01-8.716-6.747M12 21c2.485.0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485.0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997.0 017.843 4.582M12 3A8.997 8.997.0 004.157 7.582m15.686.0A11.953 11.953.0 0112 10.5c-2.998.0-5.74-1.1-7.843-2.918m15.686.0A8.959 8.959.0 0121 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919.0 0112 16.5a17.92 17.92.0 01-8.716-2.247m0 0A9.015 9.015.0 013 12c0-1.605.42-3.113 1.157-4.418"/></svg>Languages:</div><div class=font-bold>한국어</div><div><a href=http://localhost:1313/en/study/problemsolving/>English</a></div></div><p class="powered-by text-center">© 2024 Me. This work is licensed under <a href=https://creativecommons.org/licenses/by-nc-nd/4.0 rel="noopener noreferrer" target=_blank>CC BY NC ND 4.0</a></p><p class="powered-by footer-license-icons"><a href=https://creativecommons.org/licenses/by-nc-nd/4.0 rel="noopener noreferrer" target=_blank aria-label="Creative Commons"><i class="fab fa-creative-commons fa-2x" aria-hidden=true></i>
<i class="fab fa-creative-commons-by fa-2x" aria-hidden=true></i>
<i class="fab fa-creative-commons-nc fa-2x" aria-hidden=true></i>
<i class="fab fa-creative-commons-nd fa-2x" aria-hidden=true></i></a></p><p class="powered-by text-center">Published with <a href="https://hugoblox.com/?utm_campaign=poweredby" target=_blank rel=noopener>Hugo Blox Builder</a> — the free, <a href=https://github.com/HugoBlox/hugo-blox-builder target=_blank rel=noopener>open source</a> website builder that empowers creators.</p></footer></div></body></html>